import java.util.*;

class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {

        // we have to find by removing which node from initial, we can minimize the malware spread
        // let's say we have multiple components.
        // if any node in any component is in initials array then that node will spread malware to entire component.
        // if component have two nodes from initials then we cannot save that component
        // first priority is to find component where only one node is from initials.

        // for every component we will first check number of nodes which are in initials

        // we use dsu because we will get ultimate parent to represent entire component.

        int n=graph.length;
        Disjoint dsu=new Disjoint(n);
        int infected[]=new int[n]; // to track number of initially infected nodes per component.
        for(int i=0;i<graph.length;i++){
            for(int j=0;j<graph[i].length;j++){
                if(graph[i][j]==1){
                    if(dsu.findUParent(i)!=dsu.findUParent(j)){
                        dsu.unionBySize(i,j);
                    }
                }
            }
        }

        for(int node:initial){
            infected[dsu.findUParent(node)]++;
            // for every node we increment count of its component's infected count.
        }
        int maxArea=-1,ans=-1;
        Arrays.sort(initial); //why sorting??
        // because in case of two component with same size and only one infected node, we want to return node with the smallest value.
        for(int node:initial){
            int parent=dsu.findUParent(node);
            if(infected[parent]==1 && dsu.size.get(parent)>maxArea){
                // if any component has only one infected node && area of component is biggest so far then we will consider it for answer.
                // we want to remove node from component where only one node is infected, but we will try to save the biggest component.
                maxArea=dsu.size.get(parent);
                ans=node;
            }
        }
        // if answer is still zero. means we didn't find any component with only one infected node.
        if(ans==-1){
            // then as question stats, we will return node with minimum value.
            int minimumNode=Integer.MAX_VALUE;
            for(int node:initial){
                minimumNode=Math.min(minimumNode,node);
            }
            return  minimumNode;
        }
        return  ans;
    }
}

class Disjoint{
    ArrayList<Integer> rank;
    ArrayList<Integer> parent;
    ArrayList<Integer> size;
    Disjoint(int n){
        rank=new ArrayList<>();
        parent=new ArrayList<>();
        size=new ArrayList<>();

        for(int i=0;i<=n;i++){
            rank.add(0);
            parent.add(i);
            size.add(1);
        }
    }
    int findUParent(int n){
        if(parent.get(n)==n)return  n;
        int ul_p=findUParent(parent.get(n));
        parent.set(n,ul_p);
        return  ul_p;
    }
    void unionByRank(int u,int v){
        int ul_u=findUParent(u);
        int ul_v=findUParent(v);
        if(ul_u==ul_v)return;
        int ul_u_rank=rank.get(ul_u);
        int ul_v_rank=rank.get(ul_v);
        if(ul_u_rank<ul_v_rank){
            parent.set(ul_u,ul_v);
        }else if(ul_u_rank>ul_v_rank){

            parent.set(ul_v,ul_u);
        }else{
            // if both rank are same then we can do anything
            parent.set(ul_v,ul_u);
            int rankU=rank.get(ul_u_rank);
            rank.set(ul_u,rankU+1);
        }
    }
    void unionBySize(int u,int v){
        int ul_u=findUParent(u);
        int ul_v=findUParent(v);
        if(ul_u==ul_v)return;

        int ul_u_size=size.get(ul_u);
        int ul_v_size=size.get(ul_v);
        if(ul_v_size<ul_u_size){
            parent.set(ul_v,ul_u);
            int newSizeOfU=size.get(ul_v)+size.get(ul_u);
            size.set(ul_u,newSizeOfU);
        }else if(ul_v_size>ul_u_size){
            parent.set(ul_u,ul_v);
            int newSizeOfV=size.get(ul_v)+size.get(ul_u);
            size.set(ul_v,newSizeOfV);
        }else{
            parent.set(ul_u,ul_v);
            int newSizeOfV=size.get(ul_v)+size.get(ul_u);
            size.set(ul_v,newSizeOfV);
        }
    }

}
